import com.github.spotbugs.snom.Effort
import org.gradle.api.tasks.testing.logging.TestExceptionFormat

plugins {
    id "com.github.spotbugs" version "${spotbugsVersion}"
    id "java-library"
    id "io.github.gradle-nexus.publish-plugin" version "${gradleNexusPublishPlugin}"
	id "org.sonarqube" version "${sonarqubePlugin}"
    id "org.ajoberstar.git-publish" version "${gradleGitPublishPlugin}"
	id "org.openrewrite.rewrite" version "7.3.0"
	id 'project-report'
}

wrapper {
	gradleVersion = "8.13"
	distributionUrl = "https://services.gradle.org/distributions/gradle-8.13-bin.zip"
}

description = "ActionFX: A declarative, less-intrusive JavaFX MVC framework with dependency injection"

///////////////////////////////////////
// configuration for all subprojects //
///////////////////////////////////////
configure(allprojects) { project ->
 	apply plugin: "java-library"
    apply plugin: "eclipse"
    apply plugin: "idea"
	apply plugin: 'jacoco'
	apply plugin: 'project-report'
    apply plugin: "com.github.spotbugs"

	sourceCompatibility = JavaVersion.VERSION_17
	targetCompatibility = JavaVersion.VERSION_17
    
    configurations {
	    published
	    all*.exclude module: "slf4j-log4j12"
	    integrationTestImplementation.extendsFrom testImplementation
	    integrationTestRuntimeOnly.extendsFrom testRuntimeOnly
    }

      
    repositories {
        mavenCentral()
        mavenLocal()
    }

	// In this section you declare additional sourceSets
	sourceSets {
	    integrationTest {
	        java {
	            compileClasspath += main.output + test.output
	            runtimeClasspath += main.output + test.output
	            srcDir file("src/integration-test/java")
	        }
	        resources.srcDir file("src/integration-test/resources")
	    }
	}

	[compileJava, compileTestJava, compileIntegrationTestJava]*.options*.encoding = "UTF-8"

	java {
		withSourcesJar()
		withJavadocJar() 
	}
	
	test {
		useJUnitPlatform()
		jacoco {
			destinationFile = layout.buildDirectory.file("jacoco/UTest.exec").get().asFile
			enabled = true
		}
		reports {
			html.required.set(true)
			html.outputLocation.set(file("${reporting.baseDir}/${name}"))
		}

		testLogging {
			exceptionFormat = "full"
		}
    }

	tasks.withType(Test).configureEach {
		systemProperties = System.properties
		systemProperties["user.dir"] = workingDir
		reports.html.outputLocation.set(file("${reporting.baseDir}/${name}"))
		testLogging {
			events "passed", "skipped", "failed"
		}
	}

	tasks.register('integrationTest', Test) {
		useJUnitPlatform()
		testClassesDirs = sourceSets.integrationTest.output.classesDirs
		classpath = sourceSets.integrationTest.runtimeClasspath
		outputs.upToDateWhen { false }
		// test includes
		if (project.hasProperty("tests.include")) {
			include project.property("tests.include")
		}
		testLogging {
			exceptionFormat = TestExceptionFormat.FULL
		}
		afterTest { test, result ->
			println "Executing test ${test.name} [${test.className}] with result: ${result.resultType}"
		}
		jacoco {
			destinationFile = layout.buildDirectory.file("jacoco/ITest.exec").get().asFile
			enabled = true
		}
	}

	////////////////////
	// Infrastracture //
	////////////////////
    idea {
	    module {
	    }
	}

	eclipse {
	    classpath {
	        downloadSources = true
	    }
	}

	///////////////////
	// Code analysis //
	///////////////////
    spotbugs {
		effort = Effort.MAX
		reportsDir = layout.buildDirectory.file("/reports/spotbugs").get().asFile
		excludeFilter = file("$rootDir/spotbugs-filter.xml")
	}
    
    spotbugsMain {
        reports {
            html {
                destination = file("$buildDir/reports/spotbugs/spotbugs-main.html")
                stylesheet = "fancy-hist.xsl"
            }
        }
    }
    
    spotbugsTest {
        enabled = false
        ignoreFailures = true
    }
    
    spotbugsIntegrationTest {
        enabled = false
        ignoreFailures = true
    }

	////////////////////////
	// Code Quality		  //
	////////////////////////
	jacocoTestReport {
		executionData.setFrom(
				fileTree("${layout.buildDirectory.get().getAsFile().path}") {
					include("jacoco/*.exec")
				})
		reports {
			xml.required.set(true)
			xml.outputLocation.set(layout.buildDirectory.file("jacoco/coverage.xml"))
			html.required.set(true)
			csv.required.set(false)
		}
	}

	javadoc {
        description = "Generates project-level javadoc for use in -javadoc jar"

		options.memberLevel = JavadocMemberLevel.PROTECTED
        options.author = true
        options.header = project.name
        options.addStringOption("Xdoclint:none", "-quiet")
        options.addStringOption("charSet", "UTF-8")

        // suppress warnings due to cross-module @see and @link references;
        // note that global "api" task does display all warnings.
        logging.captureStandardError LogLevel.INFO
        logging.captureStandardOutput LogLevel.INFO // suppress "## warnings" message

        failOnError = false
    }
	
	// Copy Javadoc of the sub-project to the docs folder for versioning und linking in Github
	tasks.register('copyJavaDocToDocs', Copy) {
		from "$buildDir/docs/javadoc"
		into "${rootProject.projectDir}/build/docs/${version}/${project.name}"
	}
	copyJavaDocToDocs.dependsOn javadoc
	test.dependsOn copyJavaDocToDocs

	dependencies {
		compileOnly group: "com.github.spotbugs", name: "spotbugs-annotations", version: "${spotbugsAnnotationVersion}"

		testImplementation group: "org.junit.jupiter", name: "junit-jupiter-api", version: "${junitJupiterVersion}"
    	testRuntimeOnly group: "org.junit.jupiter", name: "junit-jupiter-engine", version: "${junitJupiterVersion}"
		testImplementation group: "org.assertj", name: "assertj-core", version: "${assertJVersion}"
	}
}

nexusPublishing {
    repositories {
		sonatype {
		    stagingProfileId = "3f386b79449aa"
		    nexusUrl.set(uri("https://oss.sonatype.org/service/local/"))
		    snapshotRepositoryUrl.set(uri("https://oss.sonatype.org/content/repositories/snapshots/"))
		}
    }
} 

configure(subprojects) { project ->

	initializeSonatypeStagingRepository {
        shouldRunAfter(tasks.withType(Sign))
    }	
}
	    
gitPublish {

	repoUri = 'https://github.com/martinkoster/actionfx.git'

	// message used when committing changes
	commitMessage = "Auto-publishing JavaDoc and binaries for ActionFX API version ${version}"

			
    // branch will be created if it doesn't exist
	branch = 'gh-pages'
		
	// what to publish, this is a standard CopySpec
	contents {
		from("${rootProject.projectDir}/build/docs/${version}") {
			into "docs/${version}"
		}
	}
		
	// what to keep in the existing branch (include=keep)
	preserve {
		include 'docs/**'
	}
}

sonar {
	def branchName = System.getenv("GITHUB_REF_NAME")
	properties {
		if (branchName != "master") {
			property "sonar.newCode.referenceBranch", "none"
		}
		property "sonar.projectKey", "martinkoster_actionfx"
		property "sonar.organization", "martinkoster"
		property "sonar.host.url", "https://sonarcloud.io"
		properties["sonar.tests"] += "src/integration-test/java"
		property "sonar.coverage.jacoco.xmlReportPaths", fileTree(project.rootDir.absolutePath).include("**/jacoco/coverage.xml")
		property "sonar.junit.reportPath", "${layout.buildDirectory.get().getAsFile().path}/test-results/xml/"
		property "sonar.branch.name", branchName
		property "sonar.qualitygate.wait", true
		property "sonar.branch.target", "none"
		property "sonar.exclusions", "**/Application*, **/config/*, **/generated/*"
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Tasks for incrementing the version number in gradle.properties and README files
/////////////////////////////////////////////////////////////////////////////////////////////////////

tasks.register('incMajorVersion') {
	doLast {
		def versionTokens = project.version.split("\\.")
		def newVersion = (Integer.parseInt(versionTokens[0]) + 1) + ".0.0"
		setVersionTo(newVersion)
	}
}

tasks.register('incMinorVersion') {
	doLast {
		def versionTokens = project.version.split("\\.")
		def newVersion = versionTokens[0] + "." + (Integer.parseInt(versionTokens[1]) + 1) + ".0"
		setVersionTo(newVersion)
	}
}

tasks.register('incPatchVersion') {
	doLast {
		def versionTokens = project.version.split("\\.")
		def newVersion = versionTokens[0] + "." + versionTokens[1] + "." + (Integer.parseInt(versionTokens[2]) + 1)
		setVersionTo(newVersion)
	}
}

rewrite {
	activeRecipe("org.openrewrite.staticanalysis.CommonStaticAnalysis")
	activeRecipe("org.openrewrite.java.RemoveUnusedImports")
	setExportDatatables(true)
}

dependencies {
	rewrite("org.openrewrite.recipe:rewrite-testing-frameworks:3.5.1")
	implementation 'org.junit.platform:junit-platform-commons:1.9.2'
	implementation 'org.junit.platform:junit-platform-commons:1.9.2'
}


def setVersionTo(newVersion) {
	    println("Increasing version number from ${project.version} to ${newVersion}")
	    ant.replaceregexp(match:"version\\s+=\\s+${project.version}", replace:"version							= ${newVersion}", flags:'g', byline:true) {
	        fileset(dir: '.', includes: 'gradle.properties')	    
	    }
	    ant.replaceregexp(match:"${project.version}", replace:"${newVersion}", flags:'g', byline:true) {
	        fileset(dir: '.', includes: 'README.md')	    
	        fileset(dir: './actionfx-appfactory', includes: 'README.md')
	        fileset(dir: './actionfx-app-sample', includes: 'README.md')	    
	        fileset(dir: './actionfx-controlsfx', includes: 'README.md')	    
	        fileset(dir: './actionfx-core', includes: 'README.md')	    
	        fileset(dir: './actionfx-spring-boot', includes: 'README.md')	    
	        fileset(dir: './actionfx-testing', includes: 'README.md')	    
	    }
	    
	    // specialty for appfactory: Previous and current ActionFX artifact version is defined as constant in a Java file
	    ant.replaceregexp(match:"CURRENT_ACTIONFX_VERSION = \".*\";", replace:"CURRENT_ACTIONFX_VERSION = \"${newVersion}\";", flags:'g', byline:true) {
	        fileset(dir: './actionfx-appfactory/src/main/java/com/github/actionfx/appfactory/config', includes: 'MainAppFactoryConfig.java')	    
	    }
	    ant.replaceregexp(match:"PREVIOUS_ACTIONFX_VERSION = \".*\";", replace:"PREVIOUS_ACTIONFX_VERSION = \"${project.version}\";", flags:'g', byline:true) {
	        fileset(dir: './actionfx-appfactory/src/main/java/com/github/actionfx/appfactory/config', includes: 'MainAppFactoryConfig.java')	    
	    }
}	
